# Go Authentication System with JWT, PostgreSQL, and Gin Framework (pgx Edition)

This document provides a comprehensive overview of the Go-based authentication system after migrating to the **pgx** native PostgreSQL driver. It includes details about the architecture, setup, usage, and development practices to help you understand and extend the project.

---

## 1. Project Overview

The project is a secure authentication microservice built in Go. It provides:

- User registration and login with email/password.
- JWT-based access tokens (short-lived) and refresh tokens (long-lived) stored in HTTP‑only cookies.
- Refresh token rotation with revocation.
- PostgreSQL database for storing user credentials and refresh tokens.
- Docker containerization for easy deployment.
- Database migrations managed via `golang-migrate`.
- Structured logging with `zerolog`.
- Middleware for request logging, request ID tracing, and authentication.
- **Gin web framework** for expressive routing and middleware handling.
- **pgx** as the native PostgreSQL driver and toolkit (replacing `lib/pq` and `sqlx`).

The system is designed to be integrated into larger applications as an auth service.

---

## 2. Technology Stack

| Component       | Technology                                                                 |
|-----------------|----------------------------------------------------------------------------|
| Language        | Go 1.21+                                                                   |
| Web Framework   | [Gin](https://github.com/gin-gonic/gin)                                    |
| Database        | PostgreSQL 15                                                              |
| Database Driver | [pgx](https://github.com/jackc/pgx) v5 (native interface)                  |
| Connection Pool | `pgxpool`                                                                  |
| Migrations      | `golang-migrate/migrate`                                                   |
| JWT Handling    | `golang-jwt/jwt/v5`                                                        |
| Password Hashing| `bcrypt` for passwords; `sha256` + `bcrypt` for refresh tokens             |
| UUID Generation | `google/uuid`                                                              |
| Logging         | `rs/zerolog`                                                               |
| CORS            | `rs/cors` (optional, not used directly but can be integrated)              |
| Development     | Air (hot reload)                                                           |
| Container       | Docker & Docker Compose                                                     |

---

## 3. Project Structure

```
.
├── cmd/
│   └── server/
│       └── main.go                 # Application entry point
├── internal/
│   ├── auth/
│   │   ├── jwt.go                   # JWT generation/validation
│   │   └── middleware.go             # Gin authentication middleware
│   ├── db/
│   │   └── db.go                     # Database connection (pgxpool)
│   ├── handler/
│   │   ├── auth.go                   # Auth handlers (register, login, refresh, logout, profile)
│   │   └── routes.go                  # Gin route setup
│   ├── middleware/
│   │   ├── logger.go                  # Gin request logging middleware
│   │   └── requestid.go                # Gin request ID middleware
│   ├── models/
│   │   └── models.go                   # Database models (User, RefreshToken)
│   └── repository/
│       ├── user.go                     # User repository (CRUD with pgx)
│       └── token.go                     # Refresh token repository (with pgx)
├── migrations/                           # SQL migration files
│   ├── 000001_create_users_table.up.sql
│   ├── 000001_create_users_table.down.sql
│   ├── 000002_create_refresh_tokens_table.up.sql
│   └── 000002_create_refresh_tokens_table.down.sql
├── docker-compose.yml                    # Docker Compose configuration
├── Dockerfile                            # Production Docker image
├── Dockerfile.dev                         # Development Docker image (with Air)
├── .air.toml                              # Air configuration for hot reload
├── go.mod                                 # Go module definition
└── README.md                              # This file
```

---

## 4. Prerequisites

- Docker and Docker Compose (for containerized setup)
- Go 1.21+ (only if you want to run locally without Docker)
- `make` (optional, for convenience)

---

## 5. Setup and Installation

### 5.1 Clone the repository

```bash
git clone <repository-url>
cd <project-directory>
```

### 5.2 Environment variables

Create a `.env` file (optional) or set variables in `docker-compose.yml`. The required variables are:

```env
DB_HOST=postgres
DB_PORT=5432
DB_USER=auth_user
DB_PASSWORD=auth_pass
DB_NAME=auth_db
JWT_ACCESS_SECRET=your-secret-change-me
JWT_REFRESH_SECRET=your-refresh-secret-change-me
ACCESS_TOKEN_DURATION=15m
REFRESH_TOKEN_DURATION=168h
SERVER_PORT=8080
```

> **Note:** Change the secrets in production.

### 5.3 Run with Docker Compose

```bash
docker-compose up --build
```

This will start:

- PostgreSQL on port `5432`
- Go API on port `8000` (or as configured)

The API will be available at `http://localhost:8000`.

### 5.4 Run locally (without Docker)

1. Start a PostgreSQL instance (e.g., via Docker: `docker run -d -p 5432:5432 -e POSTGRES_USER=auth_user -e POSTGRES_PASSWORD=auth_pass -e POSTGRES_DB=auth_db postgres:15-alpine`).
2. Set environment variables (or export them in your shell).
3. Run migrations manually:

   ```bash
   migrate -source file://migrations -database postgres://auth_user:auth_pass@localhost:5432/auth_db?sslmode=disable up
   ```

4. Start the server:

   ```bash
   go run cmd/server/main.go
   ```

---

## 6. Configuration

All configuration is done via environment variables:

| Variable                 | Description                              | Default     | Example               |
|--------------------------|------------------------------------------|-------------|-----------------------|
| `DB_HOST`                | PostgreSQL host                          | `postgres`  | `localhost`           |
| `DB_PORT`                | PostgreSQL port                          | `5432`      | `5432`                |
| `DB_USER`                | Database user                            | `auth_user` | `myuser`              |
| `DB_PASSWORD`            | Database password                        | `auth_pass` | `mypass`              |
| `DB_NAME`                | Database name                            | `auth_db`   | `authdb`              |
| `JWT_ACCESS_SECRET`      | Secret for signing access tokens          | *required*  | `a-long-random-string`|
| `JWT_REFRESH_SECRET`     | Secret for signing refresh tokens         | *required*  | `another-long-string` |
| `ACCESS_TOKEN_DURATION`  | Lifetime of access tokens                 | `15m`       | `30m`                 |
| `REFRESH_TOKEN_DURATION` | Lifetime of refresh tokens                | `168h`      | `720h`                |
| `SERVER_PORT`            | Port the API listens on                   | `8080`      | `8000`                |

---

## 7. Database Migrations

Migrations are managed with `golang-migrate`. The migration files are in `./migrations`.

- `000001_create_users_table.up.sql` – creates `users` table.
- `000001_create_users_table.down.sql` – drops `users` table.
- `000002_create_refresh_tokens_table.up.sql` – creates `refresh_tokens` table with foreign key to `users`.
- `000002_create_refresh_tokens_table.down.sql` – drops `refresh_tokens` table.

Migrations are applied automatically when the application starts (see `main.go`). If you need to run them manually:

```bash
migrate -source file://migrations -database postgres://auth_user:auth_pass@localhost:5432/auth_db?sslmode=disable up
```

To rollback the last migration:

```bash
migrate -source file://migrations -database postgres://auth_user:auth_pass@localhost:5432/auth_db?sslmode=disable down 1
```

---

## 8. Authentication Flow

### 8.1 Registration

1. Client sends `POST /register` with `{email, password}`.
2. Server hashes the password with bcrypt and stores the user in `users` table.
3. Server generates an access token (JWT) and a refresh token (JWT).
4. Refresh token is hashed (SHA‑256 then bcrypt) and stored in `refresh_tokens`.
5. Both tokens are set as HTTP‑only cookies in the response.

### 8.2 Login

1. Client sends `POST /login` with `{email, password}`.
2. Server verifies credentials, then proceeds like registration (generates new tokens, stores refresh token, sets cookies).

### 8.3 Accessing Protected Resources

1. Client includes cookies in requests.
2. Auth middleware (Gin) extracts the access token from the cookie (or `Authorization` header as fallback).
3. Token is validated (signature, expiration). If valid, the request proceeds with `user_id` stored in Gin context.
4. If token is missing or invalid, returns `401 Unauthorized`.

### 8.4 Refreshing Tokens

1. When access token expires, client sends `POST /refresh` with the refresh token (from cookie or JSON body).
2. Server validates the refresh token JWT, then looks up the token hash in the database (using SHA‑256 + bcrypt comparison) to ensure it hasn't been revoked.
3. If valid, server issues a new access token (and optionally a new refresh token for rotation) and sets cookies.
4. The old refresh token remains valid (unless rotation is implemented). If rotation is enabled, the old refresh token is revoked.

### 8.5 Logout

1. Client sends `POST /logout` (authenticated).
2. Server revokes **all** refresh tokens belonging to the user (sets `revoked_at`).
3. Server clears the cookies by setting empty values with expired dates.
4. Access tokens remain valid until they expire (they are not stored server-side).

---

## 9. API Endpoints Reference

All endpoints return JSON. Cookies are used for token storage; you may also send tokens via `Authorization: Bearer <token>` for the access token (if cookies are not suitable).

### 9.1 Public Endpoints

| Method | Path       | Description                      | Request Body                          | Response (success)                     |
|--------|------------|----------------------------------|---------------------------------------|----------------------------------------|
| POST   | `/register`| Create a new user                | `{"email":"...","password":"..."}`    | `201 Created`, `{"message":"..."}`     |
| POST   | `/login`   | Authenticate and receive tokens  | `{"email":"...","password":"..."}`    | `200 OK`, `{"message":"..."}`           |
| POST   | `/refresh` | Obtain new access token          | (cookies) or `{"refresh_token":"..."}`| `200 OK`, `{"message":"..."}`           |

### 9.2 Protected Endpoints (require valid access token)

| Method | Path       | Description                      | Response                               |
|--------|------------|----------------------------------|----------------------------------------|
| POST   | `/logout`  | Revoke refresh tokens and logout | `200 OK`, `{"message":"Logout successful"}` |
| GET    | `/profile` | Example protected endpoint       | `200 OK`, `User ID: <uuid>`            |

### 9.3 Error Responses

All errors return appropriate HTTP status codes and a JSON body like:

```json
{"error": "description"}
```

Common status codes:

- `400 Bad Request` – invalid input
- `401 Unauthorized` – missing or invalid token
- `403 Forbidden` – insufficient permissions (not used here)
- `404 Not Found` – resource not found
- `409 Conflict` – user already exists
- `500 Internal Server Error` – server-side issue

---

## 10. Development with Hot Reload

For development, we use **Air** to automatically rebuild and restart the server when source files change.

### 10.1 Setup

- A `Dockerfile.dev` is provided that installs Air and uses it as the entrypoint.
- The `docker-compose.yml` mounts the entire project directory to `/app` inside the container.
- Changes to `.go` files trigger a rebuild.

### 10.2 Usage

```bash
docker-compose up --build
```

Air will start and watch for changes. Logs will show `watching ...` and rebuild messages.

### 10.3 Configuration

Air is configured via `.air.toml` at the project root. It specifies:

- Build command (`go build -o ./tmp/main ./cmd/server`)
- Excluded directories (e.g., `tmp`, `vendor`)
- File extensions to watch (`.go`, `.tpl`, etc.)

You can modify the configuration as needed.

---

## 11. Database Layer with pgx

The project uses **pgx** in native mode for high performance and full PostgreSQL feature support.

### 11.1 Database Connection (`internal/db/db.go`)

```go
package db

import (
    "context"
    "fmt"
    "os"
    "time"

    "github.com/jackc/pgx/v5/pgxpool"
)

func ConnectPool(ctx context.Context) (*pgxpool.Pool, error) {
    host := os.Getenv("DB_HOST")
    port := os.Getenv("DB_PORT")
    user := os.Getenv("DB_USER")
    password := os.Getenv("DB_PASSWORD")
    dbname := os.Getenv("DB_NAME")

    connString := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
        user, password, host, port, dbname)

    config, err := pgxpool.ParseConfig(connString)
    if err != nil {
        return nil, err
    }

    config.MaxConns = 25
    config.MinConns = 5
    config.MaxConnLifetime = 5 * time.Minute
    config.MaxConnIdleTime = 1 * time.Minute

    pool, err := pgxpool.NewWithConfig(ctx, config)
    if err != nil {
        return nil, err
    }

    if err := pool.Ping(ctx); err != nil {
        return nil, err
    }

    return pool, nil
}
```

### 11.2 User Repository (`internal/repository/user.go`)

```go
package repository

import (
    "context"
    "errors"

    "myproject/internal/models"

    "github.com/google/uuid"
    "github.com/jackc/pgx/v5"
    "golang.org/x/crypto/bcrypt"
)

type UserRepo struct {
    pool *pgxpool.Pool
}

func NewUserRepo(pool *pgxpool.Pool) *UserRepo {
    return &UserRepo{pool: pool}
}

func (r *UserRepo) CreateUser(ctx context.Context, email, password string) (*models.User, error) {
    hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }

    var user models.User
    query := `INSERT INTO users (email, password_hash) VALUES ($1, $2) RETURNING id, email, password_hash, created_at, updated_at`
    err = r.pool.QueryRow(ctx, query, email, string(hashed)).Scan(
        &user.ID, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt,
    )
    if err != nil {
        return nil, err
    }
    return &user, nil
}

func (r *UserRepo) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
    var user models.User
    query := `SELECT id, email, password_hash, created_at, updated_at FROM users WHERE email = $1`
    err := r.pool.QueryRow(ctx, query, email).Scan(
        &user.ID, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt,
    )
    if errors.Is(err, pgx.ErrNoRows) {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    return &user, nil
}

func (r *UserRepo) GetUserByID(ctx context.Context, id uuid.UUID) (*models.User, error) {
    var user models.User
    query := `SELECT id, email, password_hash, created_at, updated_at FROM users WHERE id = $1`
    err := r.pool.QueryRow(ctx, query, id).Scan(
        &user.ID, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt,
    )
    if err != nil {
        return nil, err
    }
    return &user, nil
}

func (r *UserRepo) CheckPassword(user *models.User, password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
    return err == nil
}
```

### 11.3 Token Repository (`internal/repository/token.go`)

```go
package repository

import (
    "context"
    "crypto/sha256"
    "time"

    "myproject/internal/models"

    "github.com/google/uuid"
    "github.com/jackc/pgx/v5"
    "github.com/jackc/pgx/v5/pgxpool"
    "golang.org/x/crypto/bcrypt"
)

type TokenRepo struct {
    pool *pgxpool.Pool
}

func NewTokenRepo(pool *pgxpool.Pool) *TokenRepo {
    return &TokenRepo{pool: pool}
}

func (r *TokenRepo) StoreRefreshToken(ctx context.Context, userID uuid.UUID, token string, expiresAt time.Time) error {
    hash := sha256.Sum256([]byte(token))
    hashed, err := bcrypt.GenerateFromPassword(hash[:], bcrypt.DefaultCost)
    if err != nil {
        return err
    }
    query := `INSERT INTO refresh_tokens (user_id, token_hash, expires_at) VALUES ($1, $2, $3)`
    _, err = r.pool.Exec(ctx, query, userID, string(hashed), expiresAt)
    return err
}

func (r *TokenRepo) ValidateRefreshToken(ctx context.Context, token string) (uuid.UUID, error) {
    hash := sha256.Sum256([]byte(token))

    query := `SELECT id, user_id, token_hash, expires_at, revoked_at FROM refresh_tokens 
              WHERE expires_at > NOW() AND revoked_at IS NULL`
    rows, err := r.pool.Query(ctx, query)
    if err != nil {
        return uuid.Nil, err
    }
    defer rows.Close()

    for rows.Next() {
        var rt models.RefreshToken
        err = rows.Scan(&rt.ID, &rt.UserID, &rt.TokenHash, &rt.ExpiresAt, &rt.RevokedAt)
        if err != nil {
            return uuid.Nil, err
        }
        err = bcrypt.CompareHashAndPassword([]byte(rt.TokenHash), hash[:])
        if err == nil {
            return rt.UserID, nil
        }
    }
    return uuid.Nil, pgx.ErrNoRows
}

func (r *TokenRepo) RevokeAllUserTokens(ctx context.Context, userID uuid.UUID) error {
    query := `UPDATE refresh_tokens SET revoked_at = NOW() WHERE user_id = $1 AND revoked_at IS NULL`
    _, err := r.pool.Exec(ctx, query, userID)
    return err
}
```

---

## 12. Handlers (Context-Aware)

All handler methods now accept a Gin context and pass the request's context (`c.Request.Context()`) to repository functions for proper cancellation and timeout handling.

Example snippet from `Register`:

```go
func (h *AuthHandler) Register(c *gin.Context) {
    ctx := c.Request.Context()
    // ...
    existing, _ := h.userRepo.GetUserByEmail(ctx, req.Email)
    // ...
    user, err := h.userRepo.CreateUser(ctx, req.Email, req.Password)
    // ...
    if err := h.tokenRepo.StoreRefreshToken(ctx, user.ID, refreshToken, refreshExp); err != nil {
        // ...
    }
    // ...
}
```

All other handlers (`Login`, `Refresh`, `Logout`, `Profile`) follow the same pattern.

---

## 13. Logging and Monitoring

### 13.1 Request Logging

All HTTP requests are logged using a custom Gin middleware (`internal/middleware/logger.go`). Logs are structured JSON and include:

- `method` – HTTP method
- `path` – request path
- `remote_addr` – client IP
- `status` – HTTP status code
- `duration` – request processing time (human-readable string, e.g., `"12.3ms"`)
- `size` – response body size in bytes
- `user_agent` – User-Agent header
- `request_id` – unique ID for tracing (if enabled)

**Note:** The `/health` endpoint is skipped from logging to reduce noise.

Example log line:

```json
{"level":"info","method":"GET","path":"/profile","remote_addr":"172.18.0.1:51234","status":200,"duration":"2.34ms","size":45,"user_agent":"curl/7.68.0","request_id":"abc-123","time":"2026-02-20T22:15:23Z","message":"HTTP request"}
```

### 13.2 Request ID Middleware

The `RequestIDMiddleware` generates a UUID and adds it to the Gin context and response header (`X-Request-ID`). It is used in logs to correlate all log entries for a single request.

### 13.3 Error Logging

Critical errors (e.g., database failures, token storage issues) are logged with `log.Error()` and include stack traces or additional context.

### 13.4 Viewing Logs

In Docker, view logs with:

```bash
docker logs -f go_api-1
```

For local development, logs are printed to stdout.

---

## 14. Security Considerations

- **Passwords**: Hashed with bcrypt (cost 10).
- **Refresh tokens**: First hashed with SHA‑256 (to fit within bcrypt's 72-byte limit), then bcrypt hashed before storage. This prevents token theft from database leaks.
- **JWT secrets**: Use strong, randomly generated secrets; never commit them to version control.
- **HTTP‑only cookies**: Tokens are stored in cookies with `HttpOnly` and `Secure` flags (when using HTTPS). This prevents XSS attacks from stealing tokens.
- **SameSite**: Cookies use `SameSite=Strict` by default (via `SetCookie` parameters) to mitigate CSRF.
- **Short-lived access tokens**: Default 15 minutes reduces the window of misuse if a token is compromised.
- **Refresh token revocation**: On logout, all refresh tokens are revoked. You can also implement per‑user revocation if needed.
- **Database encryption at rest**: Not implemented, but you can enable PostgreSQL encryption or use cloud-managed databases.
- **Rate limiting**: Not implemented; consider adding middleware for production.

---

## 15. Testing

### 15.1 Unit Tests

Run unit tests (for packages without external dependencies):

```bash
go test ./internal/auth/...
go test ./internal/middleware/...
```

### 15.2 Integration Tests

Integration tests require a PostgreSQL instance. You can use Docker to spin up a test database.

Example using `testcontainers-go` (not yet implemented) or manually:

```bash
docker run -d --name test-db -p 5433:5432 -e POSTGRES_USER=test -e POSTGRES_PASSWORD=test -e POSTGRES_DB=testdb postgres:15-alpine
# Set environment variables for test DB, then run:
go test ./internal/repository/... -tags=integration
```

### 15.3 Manual Testing with `curl`

Use the provided examples to test endpoints. Remember to save and send cookies.

```bash
# Register
curl -X POST http://localhost:8000/register -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"secret"}' -c cookies.txt

# Login
curl -X POST http://localhost:8000/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"secret"}' -c cookies.txt

# Access protected
curl -X GET http://localhost:8000/profile -b cookies.txt

# Refresh
curl -X POST http://localhost:8000/refresh -b cookies.txt -c cookies.txt

# Logout
curl -X POST http://localhost:8000/logout -b cookies.txt -c cookies.txt
```

### 15.4 Gin Testing Utilities

Gin provides helpers for testing handlers. Example:

```go
func TestProfileHandler(t *testing.T) {
    // Setup router with test dependencies
    router := gin.New()
    router.GET("/profile", authHandler.Profile)

    // Create a request with context containing user_id
    req, _ := http.NewRequest("GET", "/profile", nil)
    w := httptest.NewRecorder()
    ctx, _ := gin.CreateTestContext(w)
    ctx.Request = req
    ctx.Set("user_id", testUserID)

    authHandler.Profile(ctx)

    assert.Equal(t, http.StatusOK, w.Code)
    assert.Contains(t, w.Body.String(), testUserID.String())
}
```

---

## 16. Troubleshooting

### 16.1 Database Connection Issues

- Ensure PostgreSQL is running and accessible from the app container.
- Check environment variables in `docker-compose.yml`.
- Run `docker exec -it go_api-1 sh` and try `ping postgres` or `nc -zv postgres 5432`.
- If using local development, ensure the host is `localhost` and port is correct.

### 16.2 Migrations Fail with "first .: file does not exist"

- The migrations directory path is incorrect. In `main.go`, we use `file://` + absolute path derived from `os.Getwd()`. Ensure the migrations folder exists at that location. You can add logging to print the path.

### 16.3 "bcrypt: password length exceeds 72 bytes"

- This error occurs when storing refresh tokens. The fix is to pre‑hash the token with SHA‑256 before bcrypt. See `internal/repository/token.go` for the correct implementation.

### 16.4 Cookies Not Being Set/Sent

- In development without HTTPS, remove the `Secure: true` flag from cookies (or set it conditionally based on environment).
- Use `curl` with `-c` and `-b` flags as shown.
- In browsers, ensure you are on the same domain and port, and that cookies are not being blocked.

### 16.5 Air Not Triggering Rebuild

- Check that the volume mount in `docker-compose.yml` is correct (e.g., `./go_api:/app`).
- Verify `.air.toml` includes the correct directories and file extensions.
- Look for Air logs like "watching ..." to confirm it's running.

### 16.6 Gin Middleware Type Errors

- Ensure all middleware functions return `gin.HandlerFunc`. The authentication middleware in `internal/auth/middleware.go` must return `gin.HandlerFunc`, not `http.Handler`.

### 16.7 Duration in Logs Shows as Number, Not String

- Verify that your logger middleware uses `Str("duration", latency.String())` or `Dur("duration", latency)`. If using `Dur` but still seeing numbers, check your `zerolog` version (should be v1.34+). Rebuild with `--no-cache` if necessary.

---

## 17. Extending the Project

### 17.1 Adding New Features

- **User roles/permissions**: Add a `role` column to `users` table, include it in JWT claims, and check in middleware.
- **Email verification**: Add a `verified` flag and send verification emails.
- **Password reset**: Implement flow with temporary tokens.
- **Multi‑device management**: List active sessions and allow per‑device logout.
- **Gin plugins**: Leverage Gin's ecosystem for rate limiting, CORS, etc.

### 17.2 Using Gin's Features

- **Route parameters**: `protected.GET("/users/:id", ...)`
- **Query parameters**: `c.Query("page")`
- **File uploads**: `c.FormFile("file")`
- **Custom validators**: Use `binding` tags with Gin's built-in validation or add your own.

### 17.3 Switching to a Different Database

If you need to use another database, you would replace `pgx` with the appropriate driver and adjust repository methods. However, `pgx` is PostgreSQL-specific; for other databases you would use `database/sql` with their drivers.

---

## 18. License

(Specify your license here, e.g., MIT, Apache 2.0)

---

This documentation provides a complete understanding of the project's architecture, usage, and development. If you have any further questions, please refer to the code or open an issue.
