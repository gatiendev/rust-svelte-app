# Go Authentication System with JWT, PostgreSQL (pgx), and Gin Framework

This document provides a comprehensive overview of the Go-based authentication system. It includes details about the architecture, setup, usage, and development practices to help you understand and extend the project.

---

## 1. Project Overview

The project is a secure authentication microservice built in Go. It provides:

- User registration and login with email/password.
- JWT-based access tokens (short-lived) and refresh tokens (long-lived) stored in HTTP‑only cookies.
- Refresh token rotation with revocation.
- PostgreSQL database for storing user credentials and refresh tokens.
- Docker containerization for easy deployment.
- Database migrations managed via `golang-migrate`.
- Structured logging with `zerolog`.
- Middleware for request logging, request ID tracing, and authentication.
- **Gin web framework** for expressive routing and middleware handling.
- **pgx** as the native PostgreSQL driver and toolkit (replacing `lib/pq` and `sqlx`).

The system is designed to be integrated into larger applications as an auth service.

---

## 2. Technology Stack

| Component       | Technology                                                                 |
|-----------------|----------------------------------------------------------------------------|
| Language        | Go 1.21+                                                                   |
| Web Framework   | [Gin](https://github.com/gin-gonic/gin)                                    |
| Database        | PostgreSQL 15                                                              |
| Database Driver | [pgx](https://github.com/jackc/pgx) v5 (native interface)                  |
| Connection Pool | `pgxpool`                                                                  |
| Migrations      | `golang-migrate/migrate`                                                   |
| JWT Handling    | `golang-jwt/jwt/v5`                                                        |
| Password Hashing| `bcrypt` for passwords; `sha256` + `bcrypt` for refresh tokens             |
| UUID Generation | `google/uuid`                                                              |
| Logging         | `rs/zerolog`                                                               |
| CORS            | `rs/cors` (optional, not used directly but can be integrated)              |
| Development     | Air (hot reload)                                                           |
| Testing         | `testify` (assert, mock), `testcontainers-go` for integration tests       |
| Container       | Docker & Docker Compose                                                     |

---

## 3. Project Structure

```
.
├── cmd/
│   └── server/
│       └── main.go                 # Application entry point
├── internal/
│   ├── auth/
│   │   ├── jwt.go                   # JWT generation/validation
│   │   └── middleware.go             # Gin authentication middleware
│   ├── db/
│   │   └── db.go                     # Database connection (pgxpool)
│   ├── handler/
│   │   ├── auth.go                   # Auth handlers (register, login, refresh, logout, profile)
│   │   └── routes.go                  # Gin route setup
│   ├── middleware/
│   │   ├── logger.go                  # Gin request logging middleware
│   │   └── requestid.go                # Gin request ID middleware
│   ├── models/
│   │   └── models.go                   # Database models (User, RefreshToken)
│   └── repository/
│       ├── interfaces.go               # Repository interfaces (for testability)
│       ├── user.go                     # User repository (pgx implementation)
│       └── token.go                     # Refresh token repository (pgx implementation)
├── migrations/                           # SQL migration files
│   ├── 000001_create_users_table.up.sql
│   ├── 000001_create_users_table.down.sql
│   ├── 000002_create_refresh_tokens_table.up.sql
│   └── 000002_create_refresh_tokens_table.down.sql
├── docker-compose.yml                    # Docker Compose configuration
├── Dockerfile                            # Production Docker image
├── Dockerfile.dev                         # Development Docker image (with Air)
├── .air.toml                              # Air configuration for hot reload
├── go.mod                                 # Go module definition
└── README.md                              # This file
```

---

## 4. Prerequisites

- Docker and Docker Compose (for containerized setup)
- Go 1.21+ (only if you want to run locally without Docker)
- `make` (optional, for convenience)

---

## 5. Setup and Installation

### 5.1 Clone the repository

```bash
git clone <repository-url>
cd <project-directory>
```

### 5.2 Environment variables

Create a `.env` file (optional) or set variables in `docker-compose.yml`. The required variables are:

```env
DB_HOST=postgres
DB_PORT=5432
DB_USER=auth_user
DB_PASSWORD=auth_pass
DB_NAME=auth_db
JWT_ACCESS_SECRET=your-secret-change-me
JWT_REFRESH_SECRET=your-refresh-secret-change-me
ACCESS_TOKEN_DURATION=15m
REFRESH_TOKEN_DURATION=168h
SERVER_PORT=8080
```

> **Note:** Change the secrets in production.

### 5.3 Run with Docker Compose

```bash
docker-compose up --build
```

This will start:

- PostgreSQL on port `5432`
- Go API on port `8000` (or as configured)

The API will be available at `http://localhost:8000`.

### 5.4 Run locally (without Docker)

1. Start a PostgreSQL instance (e.g., via Docker: `docker run -d -p 5432:5432 -e POSTGRES_USER=auth_user -e POSTGRES_PASSWORD=auth_pass -e POSTGRES_DB=auth_db postgres:15-alpine`).
2. Set environment variables (or export them in your shell).
3. Run migrations manually:

   ```bash
   migrate -source file://migrations -database postgres://auth_user:auth_pass@localhost:5432/auth_db?sslmode=disable up
   ```

4. Start the server:

   ```bash
   go run cmd/server/main.go
   ```

---

## 6. Configuration

All configuration is done via environment variables:

| Variable                 | Description                              | Default     | Example               |
|--------------------------|------------------------------------------|-------------|-----------------------|
| `DB_HOST`                | PostgreSQL host                          | `postgres`  | `localhost`           |
| `DB_PORT`                | PostgreSQL port                          | `5432`      | `5432`                |
| `DB_USER`                | Database user                            | `auth_user` | `myuser`              |
| `DB_PASSWORD`            | Database password                        | `auth_pass` | `mypass`              |
| `DB_NAME`                | Database name                            | `auth_db`   | `authdb`              |
| `JWT_ACCESS_SECRET`      | Secret for signing access tokens          | *required*  | `a-long-random-string`|
| `JWT_REFRESH_SECRET`     | Secret for signing refresh tokens         | *required*  | `another-long-string` |
| `ACCESS_TOKEN_DURATION`  | Lifetime of access tokens                 | `15m`       | `30m`                 |
| `REFRESH_TOKEN_DURATION` | Lifetime of refresh tokens                | `168h`      | `720h`                |
| `SERVER_PORT`            | Port the API listens on                   | `8080`      | `8000`                |

---

## 7. Database Migrations

Migrations are managed with `golang-migrate`. The migration files are in `./migrations`.

- `000001_create_users_table.up.sql` – creates `users` table.
- `000001_create_users_table.down.sql` – drops `users` table.
- `000002_create_refresh_tokens_table.up.sql` – creates `refresh_tokens` table with foreign key to `users`.
- `000002_create_refresh_tokens_table.down.sql` – drops `refresh_tokens` table.

Migrations are applied automatically when the application starts (see `main.go`). If you need to run them manually:

```bash
migrate -source file://migrations -database postgres://auth_user:auth_pass@localhost:5432/auth_db?sslmode=disable up
```

To rollback the last migration:

```bash
migrate -source file://migrations -database postgres://auth_user:auth_pass@localhost:5432/auth_db?sslmode=disable down 1
```

---

## 8. Authentication Flow

### 8.1 Registration

1. Client sends `POST /register` with `{email, password}`.
2. Server hashes the password with bcrypt and stores the user in `users` table.
3. Server generates an access token (JWT) and a refresh token (JWT).
4. Refresh token is hashed (SHA‑256 then bcrypt) and stored in `refresh_tokens`.
5. Both tokens are set as HTTP‑only cookies in the response.

### 8.2 Login

1. Client sends `POST /login` with `{email, password}`.
2. Server verifies credentials, then proceeds like registration (generates new tokens, stores refresh token, sets cookies).

### 8.3 Accessing Protected Resources

1. Client includes cookies in requests.
2. Auth middleware (Gin) extracts the access token from the cookie (or `Authorization` header as fallback).
3. Token is validated (signature, expiration). If valid, the request proceeds with `user_id` stored in Gin context.
4. If token is missing or invalid, returns `401 Unauthorized`.

### 8.4 Refreshing Tokens

1. When access token expires, client sends `POST /refresh` with the refresh token (from cookie or JSON body).
2. Server validates the refresh token JWT, then looks up the token hash in the database (using SHA‑256 + bcrypt comparison) to ensure it hasn't been revoked.
3. If valid, server issues a new access token (and optionally a new refresh token for rotation) and sets cookies.
4. The old refresh token remains valid (unless rotation is implemented). If rotation is enabled, the old refresh token is revoked.

### 8.5 Logout

1. Client sends `POST /logout` (authenticated).
2. Server revokes **all** refresh tokens belonging to the user (sets `revoked_at`).
3. Server clears the cookies by setting empty values with expired dates.
4. Access tokens remain valid until they expire (they are not stored server-side).

---

## 9. API Endpoints Reference

All endpoints return JSON. Cookies are used for token storage; you may also send tokens via `Authorization: Bearer <token>` for the access token (if cookies are not suitable).

### 9.1 Public Endpoints

| Method | Path       | Description                      | Request Body                          | Response (success)                     |
|--------|------------|----------------------------------|---------------------------------------|----------------------------------------|
| POST   | `/register`| Create a new user                | `{"email":"...","password":"..."}`    | `201 Created`, `{"message":"..."}`     |
| POST   | `/login`   | Authenticate and receive tokens  | `{"email":"...","password":"..."}`    | `200 OK`, `{"message":"..."}`           |
| POST   | `/refresh` | Obtain new access token          | (cookies) or `{"refresh_token":"..."}`| `200 OK`, `{"message":"..."}`           |

### 9.2 Protected Endpoints (require valid access token)

| Method | Path       | Description                      | Response                               |
|--------|------------|----------------------------------|----------------------------------------|
| POST   | `/logout`  | Revoke refresh tokens and logout | `200 OK`, `{"message":"Logout successful"}` |
| GET    | `/profile` | Example protected endpoint       | `200 OK`, `User ID: <uuid>`            |

### 9.3 Error Responses

All errors return appropriate HTTP status codes and a JSON body like:

```json
{"error": "description"}
```

Common status codes:

- `400 Bad Request` – invalid input
- `401 Unauthorized` – missing or invalid token
- `403 Forbidden` – insufficient permissions (not used here)
- `404 Not Found` – resource not found
- `409 Conflict` – user already exists
- `500 Internal Server Error` – server-side issue

---

## 10. Development with Hot Reload

For development, we use **Air** to automatically rebuild and restart the server when source files change.

### 10.1 Setup

- A `Dockerfile.dev` is provided that installs Air and uses it as the entrypoint.
- The `docker-compose.yml` mounts the entire project directory to `/app` inside the container.
- Changes to `.go` files trigger a rebuild.

### 10.2 Usage

```bash
docker-compose up --build
```

Air will start and watch for changes. Logs will show `watching ...` and rebuild messages.

### 10.3 Configuration

Air is configured via `.air.toml` at the project root. It specifies:

- Build command (`go build -o ./tmp/main ./cmd/server`)
- Excluded directories (e.g., `tmp`, `vendor`)
- File extensions to watch (`.go`, `.tpl`, etc.)

You can modify the configuration as needed.

---

## 11. Database Layer with pgx

The project uses **pgx** in native mode for high performance and full PostgreSQL feature support. The repository layer is built on **pgxpool** and all methods accept `context.Context` for proper cancellation and timeouts.

### 11.1 Repository Interfaces (for testability)

**`internal/repository/interfaces.go`**

```go
package repository

import (
    "context"
    "time"

    "myproject/internal/models"
    "github.com/google/uuid"
)

type UserRepository interface {
    CreateUser(ctx context.Context, email, password string) (*models.User, error)
    GetUserByEmail(ctx context.Context, email string) (*models.User, error)
    GetUserByID(ctx context.Context, id uuid.UUID) (*models.User, error)
    CheckPassword(user *models.User, password string) bool
}

type TokenRepository interface {
    StoreRefreshToken(ctx context.Context, userID uuid.UUID, token string, expiresAt time.Time) error
    ValidateRefreshToken(ctx context.Context, token string) (uuid.UUID, error)
    RevokeAllUserTokens(ctx context.Context, userID uuid.UUID) error
}
```

### 11.2 Database Connection (`internal/db/db.go`)

```go
package db

import (
    "context"
    "fmt"
    "os"
    "time"

    "github.com/jackc/pgx/v5/pgxpool"
)

func ConnectPool(ctx context.Context) (*pgxpool.Pool, error) {
    host := os.Getenv("DB_HOST")
    port := os.Getenv("DB_PORT")
    user := os.Getenv("DB_USER")
    password := os.Getenv("DB_PASSWORD")
    dbname := os.Getenv("DB_NAME")

    connString := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
        user, password, host, port, dbname)

    config, err := pgxpool.ParseConfig(connString)
    if err != nil {
        return nil, err
    }

    config.MaxConns = 25
    config.MinConns = 5
    config.MaxConnLifetime = 5 * time.Minute
    config.MaxConnIdleTime = 1 * time.Minute

    pool, err := pgxpool.NewWithConfig(ctx, config)
    if err != nil {
        return nil, err
    }

    if err := pool.Ping(ctx); err != nil {
        return nil, err
    }

    return pool, nil
}
```

### 11.3 User Repository (`internal/repository/user.go`)

Implements `UserRepository` using `pgxpool`.

### 11.4 Token Repository (`internal/repository/token.go`)

Implements `TokenRepository` using `pgxpool`.

---

## 12. Handlers with Dependency Injection

Handlers accept the repository interfaces, enabling easy mocking in tests.

**`internal/handler/auth.go` (constructor)**

```go
func NewAuthHandler(userRepo repository.UserRepository, tokenRepo repository.TokenRepository) *AuthHandler {
    return &AuthHandler{
        userRepo:  userRepo,
        tokenRepo: tokenRepo,
    }
}
```

All handler methods use `c.Request.Context()` when calling repository methods, ensuring proper context propagation.

---

## 13. Logging and Monitoring

### 13.1 Request Logging

All HTTP requests are logged using a custom Gin middleware (`internal/middleware/logger.go`). Logs are structured JSON and include:

- `method` – HTTP method
- `path` – request path
- `remote_addr` – client IP
- `status` – HTTP status code
- `duration` – request processing time (human-readable string, e.g., `"12.3ms"`)
- `size` – response body size in bytes
- `user_agent` – User-Agent header
- `request_id` – unique ID for tracing (if enabled)

**Note:** The `/health` endpoint is skipped from logging to reduce noise.

Example log line:

```json
{"level":"info","method":"GET","path":"/profile","remote_addr":"172.18.0.1:51234","status":200,"duration":"2.34ms","size":45,"user_agent":"curl/7.68.0","request_id":"abc-123","time":"2026-02-20T22:15:23Z","message":"HTTP request"}
```

### 13.2 Request ID Middleware

The `RequestIDMiddleware` generates a UUID and adds it to the Gin context and response header (`X-Request-ID`). It is used in logs to correlate all log entries for a single request.

### 13.3 Error Logging

Critical errors (e.g., database failures, token storage issues) are logged with `log.Error()` and include stack traces or additional context.

### 13.4 Viewing Logs

In Docker, view logs with:

```bash
docker logs -f go_api-1
```

For local development, logs are printed to stdout.

---

## 14. Security Considerations

- **Passwords**: Hashed with bcrypt (cost 10).
- **Refresh tokens**: First hashed with SHA‑256 (to fit within bcrypt's 72-byte limit), then bcrypt hashed before storage. This prevents token theft from database leaks.
- **JWT secrets**: Use strong, randomly generated secrets; never commit them to version control.
- **HTTP‑only cookies**: Tokens are stored in cookies with `HttpOnly` and `Secure` flags (when using HTTPS). This prevents XSS attacks from stealing tokens.
- **SameSite**: Cookies use `SameSite=Strict` by default (via `SetCookie` parameters) to mitigate CSRF.
- **Short-lived access tokens**: Default 15 minutes reduces the window of misuse if a token is compromised.
- **Refresh token revocation**: On logout, all refresh tokens are revoked. You can also implement per‑user revocation if needed.
- **Database encryption at rest**: Not implemented, but you can enable PostgreSQL encryption or use cloud-managed databases.
- **Rate limiting**: Not implemented; consider adding middleware for production.

---

## 15. Testing

The project includes a comprehensive test suite covering unit, integration, and end‑to‑end tests.

### 15.1 Testing Tools

- **Testify**: Assertions and mocking (`assert`, `require`, `mock`).
- **Testcontainers**: For spinning up disposable PostgreSQL instances in integration tests.
- **Gin test utilities**: `httptest` and `gin.CreateTestContext` for handler testing.

### 15.2 Unit Tests

Fast tests for packages without external dependencies (JWT helpers, middleware). Set required environment variables as needed.

```bash
go test ./internal/auth/... ./internal/middleware/... -short
```

### 15.3 Integration Tests (with Testcontainers)

Tests for repositories that require a real PostgreSQL database. They automatically start a container and run migrations.

**Run with:**

```bash
go test ./internal/repository/... -tags=integration -v
```

**Example test helper:**

```go
func setupTestDB(t *testing.T) (*pgxpool.Pool, func()) {
    // Testcontainers setup with retry and ping verification
    // ...
}
```

### 15.4 Handler Tests with Mocked Repositories

Handlers are tested using mocked repositories (generated with `testify/mock`). This verifies business logic without database overhead.

```bash
go test ./internal/handler/... -short
```

**Mock example:**

```go
type MockUserRepo struct { mock.Mock }
func (m *MockUserRepo) CreateUser(ctx context.Context, email, password string) (*models.User, error) {
    args := m.Called(ctx, email, password)
    return args.Get(0).(*models.User), args.Error(1)
}
// ...
```

### 15.5 Running All Tests

```bash
go test ./... -v
```

Integration tests will run only if the `integration` build tag is provided.

### 15.6 Continuous Integration

A sample GitHub Actions workflow is provided to run tests with a PostgreSQL service container.

---

## 16. Troubleshooting

### 16.1 Database Connection Issues

- Ensure PostgreSQL is running and accessible from the app container.
- Check environment variables in `docker-compose.yml`.
- Run `docker exec -it go_api-1 sh` and try `ping postgres` or `nc -zv postgres 5432`.
- If using local development, ensure the host is `localhost` and port is correct.

### 16.2 Migrations Fail with "first .: file does not exist"

- The migrations directory path is incorrect. In `main.go`, we use `file://` + absolute path derived from `os.Getwd()`. Ensure the migrations folder exists at that location. You can add logging to print the path.

### 16.3 "bcrypt: password length exceeds 72 bytes"

- This error occurs when storing refresh tokens. The fix is to pre‑hash the token with SHA‑256 before bcrypt. See `internal/repository/token.go` for the correct implementation.

### 16.4 Cookies Not Being Set/Sent

- In development without HTTPS, remove the `Secure: true` flag from cookies (or set it conditionally based on environment).
- Use `curl` with `-c` and `-b` flags as shown.
- In browsers, ensure you are on the same domain and port, and that cookies are not being blocked.

### 16.5 Air Not Triggering Rebuild

- Check that the volume mount in `docker-compose.yml` is correct (e.g., `./go_api:/app`).
- Verify `.air.toml` includes the correct directories and file extensions.
- Look for Air logs like "watching ..." to confirm it's running.

### 16.6 Gin Middleware Type Errors

- Ensure all middleware functions return `gin.HandlerFunc`. The authentication middleware in `internal/auth/middleware.go` must return `gin.HandlerFunc`, not `http.Handler`.

### 16.7 Duration in Logs Shows as Number, Not String

- Verify that your logger middleware uses `Str("duration", latency.String())` or `Dur("duration", latency)`. If using `Dur` but still seeing numbers, check your `zerolog` version (should be v1.34+). Rebuild with `--no-cache` if necessary.

### 16.8 Testcontainers "connection reset by peer"

- Add a small sleep after container readiness.
- Use `wait.ForAll` with both log and port listening.
- Ensure the mapped port and host are correctly retrieved.
- If using rootless Docker, try forcing network mode `bridge`.

---

## 17. Extending the Project

### 17.1 Adding New Features

- **User roles/permissions**: Add a `role` column to `users` table, include it in JWT claims, and check in middleware.
- **Email verification**: Add a `verified` flag and send verification emails.
- **Password reset**: Implement flow with temporary tokens.
- **Multi‑device management**: List active sessions and allow per‑device logout.
- **Gin plugins**: Leverage Gin's ecosystem for rate limiting, CORS, etc.

### 17.2 Using Gin's Features

- **Route parameters**: `protected.GET("/users/:id", ...)`
- **Query parameters**: `c.Query("page")`
- **File uploads**: `c.FormFile("file")`
- **Custom validators**: Use `binding` tags with Gin's built-in validation or add your own.

### 17.3 Switching to a Different Database

If you need to use another database, you would replace `pgx` with the appropriate driver and adjust repository methods. However, `pgx` is PostgreSQL-specific; for other databases you would use `database/sql` with their drivers.

---

## 18. License

(Specify your license here, e.g., MIT, Apache 2.0)

---

This documentation reflects the current state of the project, including the migration to `pgx`, repository interfaces, and the comprehensive testing strategy. For any further questions, please refer to the code or open an issue.
