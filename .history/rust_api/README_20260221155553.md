# HelpMe: Rust Authentication API with PostgreSQL and Server‑Side Cookies

## Objective

Build a high‑performance authentication API in Rust that uses **server‑side cookies** (session IDs stored in a database or Redis) and PostgreSQL as the user database. The API should support:

- User registration (password hashed with Argon2)
- Login (issues a session cookie)
- Logout (invalidates the session)
- Protected profile endpoint (requires valid session)
- All endpoints should be efficient and secure.

## Current Implementation Status

The project is fully functional with the following stack:

- **Actix Web** 4.5 – web framework
- **Actix Session** 0.9 – session management (currently using `CookieSessionStore`, which stores encrypted session data **in the cookie itself** – this is *client‑side*, not server‑side)
- **SQLx** 0.7.4 – async PostgreSQL client with migrations
- **Argon2** 0.5 – password hashing
- **PostgreSQL** 18 – user database
- **Docker Compose** – orchestrates the API, PostgreSQL, and optional Redis

The code is organized modularly and includes full error handling, logging, and session‑based authentication (without the deprecated `actix-identity`).

## Project Structure

```
my-auth-api/
├── Cargo.toml                 # Dependencies
├── .env                        # Environment variables (not committed)
├── docker-compose.yml          # Services: rust_api, postgres, (optional redis)
├── Dockerfile                  # Production build
├── Dockerfile.dev              # Development with hot‑reload
├── migrations/                 # SQLx migrations
│   └── 01_create_users_table.sql
└── src/
    ├── main.rs                 # Entry point, server setup
    ├── config.rs               # Configuration from environment
    ├── db.rs                    # Database pool creation
    ├── models/
    │   ├── mod.rs
    │   └── user.rs              # User struct and repository
    ├── handlers/
    │   ├── mod.rs
    │   └── auth.rs              # register, login, logout, profile
    └── utils/
        ├── mod.rs
        └── password.rs           # Argon2 hashing utilities
```

## Key Files Explained

### `Cargo.toml`

```toml
[package]
name = "rust_auth_api"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4.5"
actix-session = { version = "0.9", features = ["cookie-session"] }  # Remove "cookie-session" for server‑side stores
argon2 = "0.5"
rand = "0.8"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.6", features = ["v4", "serde"] }
sqlx = { version = "0.7.4", features = ["runtime-tokio-native-tls", "postgres", "uuid", "chrono", "migrate"] }
tokio = { version = "1.0", features = ["macros", "rt-multi-thread"] }
dotenv = "0.15"
anyhow = "1.0"
chrono = { version = "0.4", features = ["serde"] }
env_logger = "0.11"
```

### Environment Variables (`.env`)

```
DATABASE_URL=postgres://auth_user:auth_pass@postgres:5432/auth_db
SESSION_SECRET=your-64-byte-secret-key-here-exactly-64-characters-long...
HOST=0.0.0.0
PORT=8080
RUST_LOG=info
```

### `docker-compose.yml` (excerpt for Rust service)

```yaml
rust_api:
  build:
    context: ./rust_api
    dockerfile: Dockerfile.dev   # or Dockerfile for production
  ports:
    - "8080:8080"
  environment:
    DATABASE_URL: postgres://auth_user:auth_pass@postgres:5432/auth_db
    SESSION_SECRET: ${SESSION_SECRET}   # Must be 64 bytes
    HOST: 0.0.0.0
    PORT: 8080
    RUST_LOG: info
  volumes:
    - ./rust_api:/app            # for hot‑reload (dev only)
  depends_on:
    postgres:
      condition: service_healthy
  dns:
    - 8.8.8.8
```

### Database Migration (`migrations/20240101000000_create_users_table.sql`)

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

### `src/config.rs`

Loads config from environment.

### `src/db.rs`

Creates a connection pool using `sqlx::PgPool`.

### `src/models/user.rs`

Defines `User` struct and `UserRepository` with methods:

- `find_by_username`
- `find_by_id`
- `create`

### `src/utils/password.rs`

Provides `hash` and `verify` using Argon2.

### `src/handlers/auth.rs`

Contains the four endpoints:

- `POST /register` – creates a new user.
- `POST /login` – authenticates and stores `user_id` in the session.
- `POST /logout` – purges the session (with authentication check).
- `GET /profile` – returns user info if authenticated (reads `user_id` from session).

**Current Authentication Flow** (using `CookieSessionStore`):

- On login: `session.insert("user_id", user.id.to_string())`.
- On subsequent requests: client sends the encrypted cookie; server decrypts and reads `user_id`.
- On logout: `session.purge()`; server responds with an empty cookie (client must save it).

## How to Switch to True Server‑Side Cookies

Currently, the session data is stored **inside the cookie** (`CookieSessionStore`). This is efficient (no server‑side storage) but not truly server‑side. To use server‑side cookies (session ID only in cookie, data on server), replace `CookieSessionStore` with a persistent store like Redis or a database.

### Using Redis (Recommended)

1. Add a Redis service to `docker-compose.yml`:

   ```yaml
   redis:
     image: redis:7-alpine
     restart: unless-stopped
     networks:
       - app-network
   ```

2. Add dependency `redis` and enable `redis-rs` in `Cargo.toml`:

   ```toml
   redis = { version = "0.23", features = ["tokio-comp"] }
   actix-session = { version = "0.9", features = ["redis-rs-session"] }
   ```

3. In `main.rs`, replace `CookieSessionStore` with `RedisSessionStore`:

   ```rust
   use actix_session::{storage::RedisSessionStore, SessionMiddleware};

   let redis_store = RedisSessionStore::new("redis://redis:6379").await?;

   // In the App builder:
   .wrap(SessionMiddleware::new(redis_store, session_key.clone()))
   ```

Now the session data lives in Redis; the cookie only contains a session ID.

### Using PostgreSQL as Session Store

You can also store sessions in the same PostgreSQL database using a separate table. This is possible but requires more work (e.g., using `sqlx` to manage session records). It is generally less efficient than Redis but still server‑side.

## Running the Project

### With Docker Compose (Development)

```bash
docker-compose up --build
```

The API will be available at `http://localhost:8080`.

### Without Docker (for local development)

1. Install Rust and PostgreSQL.
2. Create a database and set `DATABASE_URL` in `.env`.
3. Run `sqlx migrate run` to apply migrations.
4. Start the server: `cargo run`.

## Testing with curl

### Register

```bash
curl -X POST http://localhost:8080/register \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","password":"secret123"}'
```

### Login (saves cookie to file)

```bash
curl -X POST http://localhost:8080/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","password":"secret123"}' \
  -c cookies.txt
```

### Profile (authenticated)

```bash
curl -X GET http://localhost:8080/profile -b cookies.txt
```

### Logout (authenticated)

```bash
curl -X POST http://localhost:8080/logout -b cookies.txt -c cookies.txt
```

### Logout without authentication

```bash
curl -X POST http://localhost:8080/logout
# returns 401
```

## Important Notes for Future Development

- **Session Secret**: Must be exactly 64 bytes. Use a strong random key and keep it secret.
- **Cookie Security**: In production, set `cookie_secure(true)` and `cookie_http_only(true)`.
- **CORS**: If the frontend is on a different domain, add the `actix-cors` middleware.
- **Rate Limiting**: Consider adding `actix-governor` or similar to prevent brute‑force attacks.
- **Session Expiry**: Configure `cookie_max_age` to control session lifetime.
- **Database Migrations**: SQLx runs migrations automatically on startup – ensure the `migrations` folder is present in the container (copied in Dockerfile).
- **Logging**: The logger middleware logs all requests; adjust `RUST_LOG` for more detail.

## Current Limitations / To‑Do

- [ ] Switch to a true server‑side session store (Redis) for better scalability and control.
- [ ] Add refresh token rotation if needed.
- [ ] Implement email verification or password reset.
- [ ] Add integration tests.
- [ ] Use a proper secret management solution (e.g., HashiCorp Vault) in production.

## Conclusion

This project provides a solid foundation for a secure authentication API in Rust. The code is modular, well‑commented, and ready to be extended. By following the instructions above, you can run it locally or in Docker, test it, and adapt it to your needs. If you need to switch to true server‑side cookies, the migration path to Redis is straightforward.
