```markdown
# Rust Authentication API with Axum and JWT

A production‑ready authentication API built with **Axum**, **PostgreSQL**, and **JWT** (access + refresh tokens). Refresh tokens are stored hashed in the database for security and revocability. The API uses HTTP‑only cookies for token storage and includes full request logging, error handling, and database migrations.

---

## Table of Contents

- [Features](#features)
- [Technology Stack](#technology-stack)
- [Architecture](#architecture)
- [Authentication Flow](#authentication-flow)
- [Security Considerations](#security-considerations)
- [Project Structure](#project-structure)
- [Setup Instructions](#setup-instructions)
  - [Prerequisites](#prerequisites)
  - [Environment Variables](#environment-variables)
  - [Running with Docker Compose](#running-with-docker-compose)
  - [Running Locally](#running-locally)
- [API Endpoints](#api-endpoints)
- [Database Schema](#database-schema)
- [Logging and Observability](#logging-and-observability)
- [Performance Tuning](#performance-tuning)
- [Future Improvements](#future-improvements)

---

## Features

- User registration with Argon2 password hashing
- Login – issues **access token** (short‑lived JWT) and **refresh token** (long‑lived, stored hashed in DB)
- Logout – invalidates the refresh token
- Token refresh – obtain a new access token using a valid refresh token (rotation)
- Profile – fetch user data with valid access token
- All tokens stored in **HTTP‑only cookies** (secure, not accessible to JavaScript)
- PostgreSQL for user data and refresh tokens
- Fully containerised with Docker Compose
- Structured logging with `tracing` and request tracing via `tower-http`

---

## Technology Stack

| Component        | Technology                                                                 |
|------------------|----------------------------------------------------------------------------|
| Web Framework    | [Axum](https://github.com/tokio-rs/axum) 0.7                              |
| Database         | PostgreSQL 15+ (via [SQLx](https://github.com/launchbadge/sqlx) 0.7)      |
| Authentication   | JWT (access tokens) + database‑backed refresh tokens                       |
| Password Hashing | Argon2id ([argon2](https://crates.io/crates/argon2) 0.5)                   |
| Token Hashing    | SHA‑256 (for refresh tokens)                                               |
| JWT Library      | [jsonwebtoken](https://crates.io/crates/jsonwebtoken) 10 (with `rust_crypto`) |
| Logging          | `tracing` + `tracing-subscriber` + `tower-http::trace`                    |
| Cookies          | `tower-cookies` 0.10                                                       |
| Runtime          | Tokio                                                                      |
| Configuration    | `dotenv` + `anyhow`                                                        |
| Containerisation | Docker, Docker Compose                                                     |

---

## Architecture

```

┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   Client    │ ──► │   Axum API  │ ──► │  PostgreSQL │
│ (Browser/   │      │ (Rust)      │      │             │
│   Mobile)   │ ◄── │             │ ◄── │             │
└─────────────┘      └─────────────┘      └─────────────┘
       │                     │                     │
       └───── Cookies ───────┘                     │
              (HTTP‑only)                           │
                                                     │
                ┌───────────────────────────────────┘
                │
                ├─ users table
                └─ refresh_tokens table

```

- **Client** stores two HTTP‑only cookies: `access_token` and `refresh_token`.
- **Access token** is a short‑lived JWT (e.g., 15 min) containing the user ID.
- **Refresh token** is a random string (high entropy), stored hashed (SHA‑256) in PostgreSQL along with its expiration.
- On each request to protected endpoints, the server validates the access token cookie.
- When the access token expires, the client can call `/refresh` with the refresh token cookie to obtain a new pair (rotation – old refresh token is invalidated, new one issued).
- Logout deletes the refresh token from the database and clears cookies.

---

## Authentication Flow

### Registration (`POST /register`)
1. Client sends `username` and `password`.
2. Server checks if username already exists.
3. Password is hashed with Argon2id (configurable parameters).
4. New user record is inserted into `users` table.
5. Returns `201 Created` with the new user ID.

### Login (`POST /login`)
1. Client sends `username` and `password`.
2. Server looks up user by username.
3. Verifies password using Argon2.
4. Generates:
   - **Access token** (JWT) – signed with secret, contains `user_id` and expiration.
   - **Refresh token** – cryptographically secure random string (e.g., 32 bytes from `rand::thread_rng` or UUIDv4).
5. Hashes the refresh token with SHA‑256 and stores it in `refresh_tokens` table with an expiration date.
6. Sets both tokens as HTTP‑only cookies (`access_token`, `refresh_token`).
7. Returns `200 OK`.

### Logout (`POST /logout`)
1. Extracts refresh token from cookies.
2. Deletes the corresponding record from `refresh_tokens` table using the token (hashed with SHA‑256 for lookup).
3. Clears both cookies.
4. Returns `200 OK`.

### Refresh (`POST /refresh`)
1. Extracts refresh token from cookies.
2. Looks up the token in the database (after SHA‑256 hashing).
3. If valid and not expired:
   - Deletes the old token (rotation).
   - Generates new access and refresh tokens.
   - Stores new refresh token (hashed) in the database.
   - Sets new cookies.
   - Returns `200 OK`.
4. If invalid/expired, returns `401 Unauthorized`.

### Profile (`GET /profile`)
1. Extracts access token from cookies.
2. Validates JWT (checks signature and expiration).
3. Extracts user ID from token claims.
4. Fetches user from database.
5. Returns user data (ID, username, created_at).

---

## Security Considerations

- **Passwords** are hashed with **Argon2id** – a memory‑hard, slow hash function. Parameters can be tuned (memory, iterations) to balance security and performance.
- **Refresh tokens** are stored as SHA‑256 hashes – fast, deterministic, and safe because the tokens themselves are high‑entropy random strings.
- **Cookies** are `HttpOnly`, `Secure` (when HTTPS is enabled), and `Path=/` – not accessible to JavaScript, reducing XSS risk.
- **JWT** is signed with a strong secret (256‑bit hex). The secret must be kept confidential.
- **Database** – only hashed refresh tokens are stored; a database leak does not expose usable tokens.
- **CORS** – not configured in this base project; add `tower-http::cors` if needed.

---

## Project Structure

```

.
├── Cargo.toml
├── .env.example
├── docker-compose.yml
├── Dockerfile
├── Dockerfile.dev
├── migrations/
│   ├── 01_create_users_table.sql
│   └── 02_create_refresh_tokens.sql
└── src/
    ├── main.rs
    ├── config.rs
    ├── db.rs
    ├── models/
    │   ├── mod.rs
    │   ├── user.rs
    │   └── refresh_token.rs
    ├── handlers/
    │   ├── mod.rs
    │   └── auth.rs
    └── utils/
        ├── mod.rs
        ├── password.rs
        ├── jwt.rs
        └── hash.rs          # SHA‑256 for refresh tokens

```

---

## Setup Instructions

### Prerequisites

- Rust (1.75+)
- Docker and Docker Compose (optional, for containerised setup)
- PostgreSQL (if running locally)

### Environment Variables

Create a `.env` file in the project root (or set in Docker) with the following:

```env
DATABASE_URL=postgres://auth_user:auth_pass@postgres:5432/auth_db
JWT_SECRET=your-64-byte-hex-secret-key-here-exactly-64-characters-long...
ACCESS_TOKEN_EXPIRATION=900          # seconds (15 minutes)
REFRESH_TOKEN_EXPIRATION=604800      # seconds (7 days)
HOST=0.0.0.0
PORT=8000
RUST_LOG=info
```

Generate a strong `JWT_SECRET`:

```bash
openssl rand -hex 32   # 64 hex characters
```

### Running with Docker Compose

```bash
docker-compose up --build
```

The API will be available at `http://localhost:8000`.

### Running Locally

1. Install PostgreSQL and create a database (e.g., `auth_db`).
2. Set the `DATABASE_URL` in `.env` to point to your local DB.
3. Run migrations:

   ```bash
   sqlx migrate run
   ```

4. Start the server:

   ```bash
   cargo run
   ```

---

## API Endpoints

| Method | Endpoint   | Description                         | Request Body                          | Success Response          |
|--------|------------|-------------------------------------|---------------------------------------|---------------------------|
| POST   | `/register`| Create a new user                   | `{"username":"string","password":"string"}` | `201 Created`             |
| POST   | `/login`   | Authenticate and get tokens (cookies) | Same as above                         | `200 OK`                  |
| POST   | `/logout`  | Invalidate refresh token, clear cookies | –                                     | `200 OK`                  |
| POST   | `/refresh` | Get new access token using refresh token | –                                     | `200 OK`                  |
| GET    | `/profile` | Get current user info (requires access token) | –                                     | `200 OK` with user data   |

All endpoints return JSON error messages on failure (e.g., `{"message":"..."}`).

---

## Database Schema

### `users`

| Column        | Type      | Description                         |
|---------------|-----------|-------------------------------------|
| id            | UUID      | Primary key (default gen_random_uuid) |
| username      | TEXT      | Unique, not null                    |
| password_hash | TEXT      | Argon2 hash                         |
| created_at    | TIMESTAMPTZ | Default now()                       |

### `refresh_tokens`

| Column        | Type      | Description                         |
|---------------|-----------|-------------------------------------|
| id            | UUID      | Primary key                         |
| user_id       | UUID      | Foreign key → users(id) on delete cascade |
| token_hash    | TEXT      | SHA‑256 hash of the raw refresh token (unique) |
| expires_at    | TIMESTAMPTZ | Expiration timestamp                |
| created_at    | TIMESTAMPTZ | Default now()                       |

Indexes:

- `token_hash` (for fast lookup)
- `user_id`

---

## Logging and Observability

- The application uses the `tracing` crate for structured logging.
- `tower_http::trace::TraceLayer` logs each request (method, URI, status, latency).
- Log level is controlled by the `RUST_LOG` environment variable (e.g., `info`, `debug`).
- In `main.rs`, a custom `TraceLayer` is configured to log request start and finish at `INFO` level.
- Additional timing logs are inserted in critical handlers (e.g., login steps) to aid performance analysis.

---

## Performance Tuning

- **Argon2 parameters** – adjust memory and iteration cost in `password.rs` to achieve desired verification time (e.g., 300–500 ms in production). Lower values (~4 MB) are used in development for speed.
- **Refresh token hashing** – uses SHA‑256 (fast) – ensure you are **not** accidentally using Argon2 for refresh tokens.
- **Database connection pool** – configured with `max_connections` and `min_connections` in `db.rs`. Increase if under load.
- **Blocking operations** – password hashing/verification is CPU‑intensive; wrap calls in `tokio::task::spawn_blocking` to avoid blocking the async runtime (already done if using `password::verify` from the provided utils – verify implementation is synchronous, so you should call it inside `spawn_blocking` in production).

Example of offloading password verification:

```rust
let user = ...;
let valid = tokio::task::spawn_blocking(move || {
    password::verify(&req.password, &user.password_hash)
})
.await
.unwrap_or(Ok(false))?;
```

---

## Future Improvements

- Add rate limiting (e.g., `tower-governor`) to prevent brute‑force attacks.
- Implement email verification or password reset.
- Add CORS middleware if frontend is on a different domain.
- Use environment‑specific Argon2 parameters (higher in production).
- Rotate JWT secret and provide a mechanism to invalidate all refresh tokens.
- Add integration tests.
- Use a secrets manager (e.g., HashiCorp Vault) for production secrets.

---

## Contributing / Extending

This project is designed to be modular. To add new features:

- **New models** – add to `src/models/` and define repository methods.
- **New handlers** – add to `src/handlers/` and register routes in `main.rs`.
- **New utilities** – add to `src/utils/`.

All handlers receive the application state, which contains database repositories and configuration.

---

## License

MIT (or your preferred license).

---

## Contact

For questions or contributions, please open an issue or pull request on the repository.

```
