# Go Cheatsheet â€“ 20% of the language, 80% of the time

*Based on realâ€‘world patterns from a Binance WebSocket client, extended with essential Go concepts not covered in that code.*

---

## ğŸ“¦ Package & Imports

```go
package main // executable programs start with package main

import (
    "fmt"
    "log"
    "github.com/gorilla/websocket" // external imports
)
```

- Every Go file belongs to a package.
- `main` package defines an executable program.
- Imports are grouped: standard library first, then thirdâ€‘party.
- Unexported identifiers start with lowercase; exported with uppercase.

---

## ğŸ—ï¸ Constants & Variables

```go
const binanceWS = "wss://stream.binance.com:9443/ws" // untyped constant
const MaxRetries = 3                                 // typed constant

var count = 10            // type inferred
var name string           // zero value ("")
age := 30                  // short declaration (inside functions only)
```

- Use `const` for values that never change.
- `var` declares variables (zeroâ€‘value initialized).
- `:=` is shorthand for declaration + assignment (only inside functions).

---

## ğŸ§± Structs (Your Main Data Containers)

```go
type TickerData struct {
    EventType string `json:"e"`  // field tags control JSON (de)serialization
    LastPrice string `json:"c"`
    Volume    string `json:"v,omitempty"` // omit if zero
}
```

- Fields start with a capital letter to be exported (JSON package needs this).
- Struct tags provide metadata (e.g., `json:"name"`).
- Use `omitempty` to skip zero values in JSON.

---

## ğŸ§  Functions & Multiple Returns

```go
func streamPrices(ctx context.Context) error { // returns error
    // ...
    return nil
}

// Named return values (rare, but can improve readability)
func divide(a, b float64) (result float64, err error) {
    if b == 0 {
        err = errors.New("division by zero")
        return
    }
    result = a / b
    return
}
```

- Functions can return multiple values â€“ idiomatic for results + error.
- Error is usually the last return value.
- Named return values act as variables declared in the function signature.

---

## â— Error Handling â€“ The Go Way

```go
if err != nil {
    return fmt.Errorf("failed to connect: %w", err) // wrap error with %w
}

log.Fatal("Error:", err) // logs and exits (use only in main/init)
log.Printf("Warning: %v", err) // nonâ€‘fatal logging
```

- Always check errors immediately.
- Wrap errors with `%w` to preserve context.
- Use `errors.Is` and `errors.As` to inspect wrapped errors.

---

## ğŸš¦ Control Flow

### If with initialization

```go
if err := conn.WriteJSON(msg); err != nil {
    return err
}
```

### For (Goâ€™s only loop)

```go
for { // infinite loop
    // ...
}

for i := 0; i < 10; i++ { ... }

for key, value := range map { ... }

for index, value := range slice { ... }
```

### Switch

```go
switch day {
case "Monday", "Tuesday":
    fmt.Println("Weekday")
default:
    fmt.Println("Other")
}
// No fallthrough by default; use `fallthrough` explicitly.
```

### Select (for channels)

```go
select {
case <-ctx.Done():
    return
case msg := <-ch:
    handle(msg)
default:
    // nonâ€‘blocking work
}
```

---

## â±ï¸ Defer â€“ Cleanup Made Simple

```go
conn, err := websocket.Dial(...)
if err != nil {
    return err
}
defer conn.Close() // executes when surrounding function returns
```

- Deferred calls run in LIFO order.
- Perfect for closing files, connections, mutex unlocks.
- Deferred functions can access and modify named return values.

---

## ğŸ§µ Goroutines & Channels

```go
go func() {
    <-sigs
    cancel()
}()
```

- Launch a goroutine with `go`.
- Communicate via channels (typeâ€‘safe queues).

### Channel basics

```go
ch := make(chan int)    // unbuffered (blocks until both sides ready)
ch := make(chan int, 5) // buffered (holds 5 values)

ch <- 42        // send
value := <-ch   // receive
close(ch)       // no more sends
```

### Ranging over channel

```go
for msg := range ch {
    fmt.Println(msg)
}
```

### WaitGroup â€“ synchronize goroutines

```go
var wg sync.WaitGroup
for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        // do work
    }(i)
}
wg.Wait()
```

---

## ğŸŒ Context â€“ Cancellation & Deadlines

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

// With timeout
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

// In a goroutine or loop:
select {
case <-ctx.Done():
    return ctx.Err() // cancelled or deadline exceeded
default:
    // continue work
}
```

- Context propagates cancellation across API boundaries.
- Use `WithCancel`, `WithTimeout`, or `WithValue` (for requestâ€‘scoped values).

---

## ğŸ”Œ JSON â€“ Encoding & Decoding

```go
// Decode into a struct
var ticker TickerData
if err := json.Unmarshal(msg, &ticker); err != nil {
    return err
}

// Decode into a map
var raw map[string]interface{}
json.Unmarshal(msg, &raw)

// Encode to JSON
data, _ := json.Marshal(myStruct)
json.NewEncoder(w).Encode(myStruct) // streaming to http.ResponseWriter
```

- Use struct tags to control field names.
- Always handle the error from `Unmarshal`.

---

## ğŸ§© Type Assertions & Commaâ€‘Ok Idiom

```go
if result, ok := raw["result"]; ok {
    // "result" exists and is stored in result
}

var i interface{} = "hello"
s, ok := i.(string) // safe type assertion
if !ok {
    // not a string
}
```

- Used with maps, interface conversions, and channel receives.
- `ok` is `true` if the operation succeeded.

---

## ğŸ“¡ Signal Handling â€“ Graceful Shutdown

```go
sigs := make(chan os.Signal, 1)
signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

go func() {
    <-sigs
    cancel() // cancel context, trigger cleanup
}()
```

- Capture OS signals to shut down gracefully.
- Always use a buffered channel (size 1) for signals.

---

## ğŸ”§ Essential Concepts Not in the Example Code

### Interfaces

```go
type Writer interface {
    Write([]byte) (int, error)
}
// Any type with Write method satisfies io.Writer.
// Interfaces enable loose coupling and polymorphism.
```

### Pointers

```go
func (p *Person) SetAge(age int) { // method with pointer receiver
    p.Age = age
}
// Use *T to modify original value or avoid copying.
// &v takes address of v.
```

### Slices â€“ dynamic arrays

```go
s := []int{1,2,3}
s = append(s, 4)
copy(dst, src)
// Slices are references to underlying arrays.
```

### Maps

```go
m := make(map[string]int)
m["key"] = 42
value, ok := m["key"]
delete(m, "key")
```

### Make & New

```go
ch := make(chan int, 5)        // for channels, slices, maps
ptr := new(int)                 // allocates zero value, returns *int
```

### Panic & Recover

```go
defer func() {
    if r := recover(); r != nil {
        log.Println("recovered from", r)
    }
}()
// Panic for truly exceptional situations; recover only in deferred functions.
```

### Struct Embedding (Composition)

```go
type Reader struct { ... }
type Writer struct { ... }
type ReadWriter struct {
    Reader
    Writer
}
// Methods of embedded types are promoted.
```

### Blank Identifier

```go
_, err := doSomething() // ignore first return value
```

### Testing

```go
// file: main_test.go
func TestAdd(t *testing.T) {
    result := add(2,3)
    if result != 5 {
        t.Errorf("expected 5, got %d", result)
    }
}
// Run with: go test
```

---

## ğŸ§ª Common Patterns from the Code

- **Infinite loop with select**: `for { select { case <-ctx.Done(): return; default: } }`
- **Wrapping errors**: `fmt.Errorf("context: %w", err)`
- **Defer with anonymous function** if more logic needed: `defer func() { ... }()`
- **Check for specific error types**: `websocket.IsCloseError(err, websocket.CloseNormalClosure)`

---

## ğŸ§° Tooling & Environment

- `go mod init <module>` â€“ create a new module.
- `go get <package>` â€“ add dependency.
- `go build` â€“ compile.
- `go run main.go` â€“ build and run.
- `go fmt` â€“ format code automatically.
- `go test` â€“ run tests.
- `go doc <package>` â€“ view documentation.

---

## ğŸ§  Mindset

- **Errors are values** â€“ handle them explicitly.
- **Donâ€™t communicate by sharing memory; share memory by communicating** (channels).
- **Concurrency is not parallelism** â€“ goroutines allow concurrent design; parallelism is automatic when available.
- **Zero values** are your friend â€“ no uninitialized variables.
- **Accept interfaces, return structs** â€“ flexible APIs.

---

This cheatsheet now covers the 20% of Go that yields 80% of the results, including both the patterns from your Binance client and essential language features missing from that example. Youâ€™re ready to build robust, idiomatic Go applications.
